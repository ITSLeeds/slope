% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slopes.R
\name{slope_vector}
\alias{slope_vector}
\alias{slope_distance}
\alias{slope_distance_mean}
\alias{slope_distance_weighted}
\title{Calculate the gradient of line segments from distance and elevation vectors}
\usage{
slope_vector(x, e)

slope_distance(d, e)

slope_distance_mean(d, e)

slope_distance_weighted(d, e)
}
\arguments{
\item{x}{Vector of locations}

\item{e}{Elevations in same units as x (assumed to be metres)}

\item{d}{Vector of distances between points}
}
\description{
\code{\link[=slope_vector]{slope_vector()}} calculates the slopes associated with consecutive elements
in one dimensional distance and associated elevations (see examples).

\code{\link[=slope_distance]{slope_distance()}} calculates the slopes associated with consecutive
distances and elevations.

\code{\link[=slope_distance_mean]{slope_distance_mean()}} calculates the mean average slopes associated with
consecutive distances and elevations.

\code{\link[=slope_distance_weighted]{slope_distance_weighted()}} calculates the slopes associated with
consecutive distances and elevations,
with the mean value associated with each set of distance/elevation
vectors weighted in proportion to the distance between each elevation
measurement, so longer sections have proportionally more influence
on the resulting gradient estimate (see examples).
}
\examples{
x = c(0, 2, 3, 4, 5, 9)
e = c(1, 2, 2, 4, 3, 1) / 10
slope_vector(x, e)
m = sf::st_coordinates(lisbon_road_segment)
d = sequential_dist(m, lonlat = FALSE)
e = elevation_extract(m, dem_lisbon_raster)
slope_distance(d, e)
slope_distance_mean(d, e)
slope_distance_weighted(d, e)
}
