---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# slopes package

<!-- badges: start -->
[![R-CMD-check](https://github.com/itsleeds/slopes/workflows/R-CMD-check/badge.svg)](https://github.com/itsleeds/slopes/actions)
[![Codecov test coverage](https://codecov.io/gh/itsleeds/slopes/branch/master/graph/badge.svg)](https://codecov.io/gh/itsleeds/slopes?branch=master)
[![Status at rOpenSci Software Peer Review](https://badges.ropensci.org/420_status.svg)](https://github.com/ropensci/software-review/issues/420)
<!-- badges: end -->

The **slopes** R package calculates the slope (longitudinal steepness, also known as gradient) of roads, rivers and other linear (simple) features, based on two main inputs:

- [vector](https://geocompr.robinlovelace.net/spatial-class.html#vector-data) linestring geometries defined by classes in the [`sf`](https://r-spatial.github.io/sf/) package
- [raster](https://geocompr.robinlovelace.net/spatial-class.html#raster-data) objects with pixel values reporting average height, commonly known as digital elevation model (**DEM**) datasets, defined by classes in the [`raster`](https://cran.r-project.org/package=raster) or more recent [`terra`](https://rspatial.org/terra) packages

This README covers installation and basic usage. For more information about slopes and how to use the package to calculate them, see the [get started](https://itsleeds.github.io/slopes/) and the [introducion to slopes](https://itsleeds.github.io/intro-to-slopes/) vignette.


## How it works

The package takes two main types of input data for slope calculation: 
- vector geographic objects representing **linear features**, and 
- **elevation values** from a digital elevation model representing a continuous terrain surface or which can be downloaded using functionality in the package

The package can be used with two sources of elevation data:
- openly available elevation data via an interface to the [ceramic package](https://github.com/hypertidy/ceramic), enabling estimation of hilliness for routes anywhere worldwide even when local elevation data is lacking. The package takes geographic lines objects and returns elevation data per vertex (providing the output as a 3D point geometry in the sf package by default) and per line feature (providing average gradient by default).
- an elevation model, available on your machine.

## Getting started

### Installation

<!-- You can install the released version of slopes from [CRAN](https://CRAN.R-project.org) with: -->

<!-- ``` r -->
<!-- install.packages("slopes") -->
<!-- ``` -->

Install the development version from [GitHub](https://github.com/) with:

```{r, eval=FALSE}
# install.packages("remotes")
remotes::install_github("itsleeds/slopes")
```

#### Installation for DEM downloads

If you do not already have DEM data and want to make use of the package's ability to download them using the `ceramic` package, install the package with suggested dependencies, as follows:

```{r, eval=FALSE}
# install.packages("remotes")
remotes::install_github("itsleeds/slopes", dependencies = "Suggests")
```

Furthermore, you will need to add a MapBox API key to be able to get DEM datasets, by signing up and registering for a key at https://account.mapbox.com/access-tokens/ and then following these steps:

```{r, eval=FALSE}
usethis::edit_r_environ()
MAPBOX_API_KEY=xxxxx # replace XXX with your api key
```

## Basic examples

Load the package in the usual way. We will also load the `sf` library:

```{r message=FALSE, warning=FALSE}
library(slopes)
library(sf)
```

The minimum input data requirement for using the package is an `sf` object containing LINESTRING geometries.  

### Sinlge road segment + no DEM

In this example, we use a single linestring object `lisbon_road_segment` that is contained within the package.

```{r}
sf_linestring = lisbon_road_segment # import or load a linestring
```

A quick way of testing if your object can have slopes calculated for it is to plot it in an interactive map and to check that underneath the object there is indeed terrain that will give the linestrings gradient:

```{r}
library(tmap)
tmap_mode("view")
tm_shape(sf_linestring) +
  tm_lines(lwd = 5) +
  tm_basemap(leaflet::providers$Esri.WorldTopoMap)
```

we can calculate its gradient as a two step process, as follows.

**Step 1**: add elevations to each coordinate in the linestring (requires a [MapBox API](https://account.mapbox.com/access-tokens/) key):

```{r, eval=FALSE}
sf_linestring_xyz = elevation_add(sf_linestring)  # dem = NULL
#> Loading required namespace: ceramic
#> Preparing to download: 9 tiles at zoom = 18 from 
#> https://api.mapbox.com/v4/mapbox.terrain-rgb/
```
```{r, echo=FALSE}
# note: the following should be TRUE
# identical(sf_linestring_xyz, lisbon_road_segment_xyz_mapbox)
sf_linestring_xyz = lisbon_road_segment_xyz_mapbox
```

With the argument `dem = NULL`, the function downloads the necessary elevation information from Mapbox. You can use this argument with a local digital elevation model (`dem = ...`).

You can check the elevations added to the new `sf_linestring_xyz` object by printing its coordinates with `st_coordinates()`, or you can use the `z_` functions to extract such values, as follows:

```{r}
z_value(sf_linestring_xyz) # returns all the elevation values between xy coordinates

z_mean(sf_linestring_xyz) # elevation mean value
z_min(sf_linestring_xyz) # elevation min value 
z_max(sf_linestring_xyz) # elevation max value 
z_start(sf_linestring_xyz) # first z
z_end(sf_linestring_xyz) # last z
```

Note the linestring goes from 88 m above sea level to only 80 m in a short distance.

**Step 2**: calculate the average slope of the linestring

```{r}
slope_xyz(sf_linestring_xyz)
```

The result, just over 0.2, tells us that it's quite a steep slope: a 21% gradient *on average*.

### Route + available DEM

Using the slopes package we can estimate the gradient of individual road segments. When these segments are combined into routes, we then need a means of assessing the hilliness of the entire route. A range of indices can be used to represent route hilliness. The choice of which index is most appropriate may be context dependent (see the [introducion to slopes](https://itsleeds.github.io/intro-to-slopes/) vignette).
  
This example uses the same function with a entire route, `lisbon_route`, also available in the package.

```{r message=FALSE, warning=FALSE}
sf_route = lisbon_route

tm_shape(sf_route) +
  tm_lines(lwd = 3) +
  tm_basemap(leaflet::providers$Esri.WorldTopoMap)
```

**Step 1**: add elevations to each coordinate in the route:

```{r, eval=FALSE}
sf_route_xyz = elevation_add(sf_route)
#> Loading required namespace: ceramic
#> Preparing to download: 12 tiles at zoom = 15 from 
#> https://api.mapbox.com/v4/mapbox.terrain-rgb/
```

```{r, echo=FALSE}
# note: the following should be TRUE
# identical(sf_route_xyz, lisbon_road_segment_xyz_mapbox)
sf_route_xyz = lisbon_route_xyz_mapbox
```

The result shows a 7.7% gradient *on average*.

Now, if you already have a DEM, you can calculate the slopes directly as follows, with `slope_raster()`:

```{r}
class(dem_lisbon_raster)
slope_raster(routes = sf_route,
             dem = dem_lisbon_raster) #a raster dataset included in the package:
```
The result shows a 7.8% gradient *on average*.
As you can see, the retrieved result from elevation information available in Mapbox and in this Digital Elevation Model, is quite similar. (See more about these differences in [Verification of slopes](https://itsleeds.github.io/slopes/articles/verification.html).) 

### Route with xyz coordinates

If your linestring object already has X, Y and Z coordinates (e.g. from a GPS device), you can use the `slope_` functions directly. 

```{r eval=FALSE, include=FALSE}
#not to use like this... it would be good to have a gps example to demonstrate

slope_vector(sf_route_xyz)
slope_distance(sf_route_xyz)
slope_distance_mean(sf_route_xyz)
slope_distance_weighted(sf_route_xyz)

slope_vector(sf_linestring_xyz)
slope_distance(sf_linestring_xyz)
slope_distance_mean(sf_linestring_xyz)
slope_distance_weighted(sf_linestring_xyz)
```
```{r}
# for a line xz
x = c(0, 2, 3, 4, 5, 9)
elevations = c(1, 2, 2, 4, 3, 1) / 10
slope_vector(x, elevations)


# for a path xyz
xy = st_coordinates(sf_linestring)
dist = sequential_dist(xy, lonlat = FALSE)
elevations = elevation_extract(xy, dem_lisbon_raster)

slope_distance(dist, elevations)
slope_distance_mean(dist, elevations)
slope_distance_weighted(dist, elevations)
```

In any case, to use the `slopes` package you need **elevation points**, either as a vector, a matrix or as a digital elevation model (DEM) encoded as a raster dataset.

_See more functions in [Get started](https://itsleeds.github.io/slopes/articles/slopes.html) vignette._

## Calculating and plotting the gradient of roads

### Road network
Typical use cases for the package are calculating the slopes of geographic objects representing roads or other linear features.
These two types of input data are represented in the code output and plot below.

```{r dem-lisbon}
# A raster dataset
summary(raster::values(dem_lisbon_raster)) # heights range from 0 to ~100m
raster::plot(dem_lisbon_raster)

# A vector dataset 
plot(sf::st_geometry(lisbon_road_network), add = TRUE)
```

Calculate the average gradient of **each road segment** as follows:

```{r}
lisbon_road_network$slope = slope_raster(lisbon_road_network,
                                         dem = dem_lisbon_raster)
```

This created a new column, `slope` that represents the average, distance weighted slope associated with each road segment.
The units represent the percentage incline, that is the change in elevation divided by distance.

```{r}
summary(lisbon_road_network$slope)
```

The summary of the result tells us that the average gradient of slopes in the example data is just over 5%.

We can now visualise the average slopes of each route calculated by the `slopes` package as follows:

```{r slope-vis}
raster::plot(dem_lisbon_raster)
plot(lisbon_road_network["slope"], add = TRUE, lwd = 5)
```

### Elevation profile

Taking the [first route example](#route--available-dem), imagine that we want to go from from _Santa Catarina_ in the East of the map to the _Castelo de São Jorge_ in the West.
This route goes down a valley and up the other side.

```{r route, eval=FALSE, include=FALSE}
# library(tmap)
# tmap_mode("view")
qtm(lisbon_route) #repetition for README. Included in Get Started.
```

We can convert the `lisbon_route` object into a 3d linestring object with X, Y and Z coordinates, using the elevation values stored in the DEM, as follows:

```{r, warning=FALSE, echo=FALSE, eval=FALSE}
sln = stplanr::SpatialLinesNetwork(lisbon_road_network)
points = sf::st_as_sf(crs = 4326, coords = c("X1", "X2"), data.frame(rbind(
  stplanr::geo_code("Santa Catarina, Lisbon"),
  stplanr::geo_code("Castelo, Lisbon")
)))
points_proj = sf::st_transform(points, sf::st_crs(lisbon_road_network))
coords = sf::st_coordinates(points_proj)
nodes = stplanr::find_network_nodes(sln, coords[, 1], coords[, 2])
lisbon_route = stplanr::sum_network_routes(sln = sln, start = nodes[1], end = nodes[2])
mapview::mapview(lisbon_route) +
  mapview::mapview(lisbon_road_network["slope"])
lisbon_route_3d = elevation_add(lisbon_route, dem_lisbon_raster)
usethis::use_data(lisbon_route, overwrite = TRUE)
usethis::use_data(lisbon_route_3d, overwrite = TRUE)
```

```{r}
lisbon_route_xyz = elevation_add(lisbon_route, dem_lisbon_raster)
```

We can now visualise the elevation profile of the route as follows:

```{r plot_slope}
plot_slope(lisbon_route_xyz)
```

### Using `elevation_add()` with and without a `dem =` argument

If you do not have a raster dataset representing elevations, you can automatically download them by omitting the argument `dem = NULL` (a step that is automatically done in the function `elevation_add()` shown in the basic example above, results of the subsequent code chunk not shown):

```{r, message=FALSE, warning=FALSE, eval=FALSE}
dem_mapbox = elevation_get(lisbon_route)
lisbon_road_proj = st_transform(lisbon_route, raster::crs(dem_mapbox))
lisbon_route_xyz_mapbox = elevation_add(lisbon_road_proj, dem = dem_mapbox)
plot_slope(lisbon_route_xyz_mapbox)
```


As outlined in the basic example above this can be done more concisely, as:

```{r, eval=FALSE}
lisbon_route_xyz_auto = elevation_add(lisbon_route) #dem = NULL
```
```{r, echo=FALSE}
lisbon_route_xyz_auto = lisbon_route_xyz_mapbox
```
```{r}
plot_slope(lisbon_route_xyz_auto)
```

Note that the elevations shown in both plots differ, since the first is based on DEM elevation available, and the second is based in _Mapbox_ elevation.

## See more in vignettes

-   [Get started](https://itsleeds.github.io/slopes/articles/slopes.html)
-   [An introduction to slopes](https://itsleeds.github.io/slopes/articles/intro-to-slopes.html)
-   [Reproducible example: gradients of a road network for a given city](https://itsleeds.github.io/slopes/articles/roadnetworkcycling.html)
-   [Verification of slopes](https://itsleeds.github.io/slopes/articles/verification.html)
-   [Benchmarking slopes calculation](https://itsleeds.github.io/slopes/articles/benchmark.html)



## Code of Conduct

Please note that the slopes project is released with a [Contributor Code of Conduct](https://contributor-covenant.org/version/2/0/CODE_OF_CONDUCT.html). By contributing to this project, you agree to abide by its terms.

